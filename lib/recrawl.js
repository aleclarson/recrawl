// Generated by CoffeeScript 2.3.0
var Follower, Matcher, S_IFDIR, S_IFLNK, S_IFMT, alwaysFalse, alwaysTrue, fs, globRegex, limitDepth, lstatSync, matchAny, notBasedRE, path, readdirSync, readlinkSync, recrawl, relative, statSync;

globRegex = require('glob-regex');

relative = require('@cush/relative');

path = require('path');

fs = require('fs');

({lstatSync, readdirSync, readlinkSync, statSync} = fs);

({S_IFMT, S_IFLNK, S_IFDIR} = fs.constants);

alwaysTrue = function() {
  return true;
};

alwaysFalse = function() {
  return false;
};

limitDepth = function(limit) {
  return function(path, depth) {
    return depth < limit;
  };
};

recrawl = function(opts = {}) {
  var enter, filter, follow, maxDepth, only, skip;
  ({only, skip, enter, filter, follow} = opts);
  only = Matcher(only, alwaysTrue);
  skip = Matcher(skip, alwaysFalse);
  enter || (enter = alwaysTrue);
  filter || (filter = alwaysTrue);
  follow && (follow = (follow === true && Follower(alwaysTrue)) || (typeof follow === 'number' && Follower(limitDepth(follow))) || (typeof follow === 'function' && Follower(follow)));
  maxDepth = typeof opts.depth === 'number' ? Math.max(0, opts.depth) : opts.deep === false ? 0 : 1 / 0;
  return function(root, arg) {
    var crawl, depth, each, files;
    root = path.resolve(root) + path.sep;
    if (arg) {
      if (typeof arg === 'function') {
        each = arg;
      } else if (typeof arg === 'object') {
        files = arg;
      }
    }
    if (!each) {
      files || (files = follow && {} || []);
      each = Array.isArray(files) ? function(file) {
        return files.push(file);
      } : function(file, link) {
        files[file] = link || true;
      };
    }
    depth = 0;
    crawl = function(dir) {
      var base, i, len, mode, name, ref;
      ref = readdirSync(root + dir);
      for (i = 0, len = ref.length; i < len; i++) {
        base = ref[i];
        name = dir + base;
        if (skip(name, base)) {
          continue;
        }
        mode = statSync(root + name).mode & S_IFMT;
        if (mode === S_IFDIR) {
          if (depth === maxDepth) {
            continue;
          }
          if (enter(name, depth)) {
            depth += 1;
            crawl(name + '/');
            depth -= 1;
          }
          continue;
        }
        if (only(name, base) && filter(name, base)) {
          mode = follow && lstatSync(root + name).mode & S_IFMT;
          each(name, mode === S_IFLNK ? follow(name, root) : null);
        }
      }
      return files;
    };
    return crawl('');
  };
};

module.exports = recrawl;


// Helpers

notBasedRE = new RegExp(`(?:\\${path.sep}|\\*\\*)`);

matchAny = function(patterns) {
  return new RegExp('^(?:' + patterns.join('|') + ')$');
};

Matcher = function(globs, matchEmpty) {
  var baseRE, nameRE;
  if (typeof globs === 'string') {
    globs = [globs];
  } else if (!globs || !globs.length) {
    return matchEmpty;
  }
  nameRE = []; // match against root relatives
  baseRE = []; // match against basenames
  globs.forEach(function(glob) {
    if (notBasedRE.test(glob)) {
      if (glob[0] === path.sep) {
        glob = glob.slice(1);
      } else if (glob[0] !== '*') {
        glob = '**/' + glob;
      }
      if (glob.slice(-1) === '/') {
        glob += '**';
      }
      return nameRE.push(globRegex.replace(glob));
    } else {
      return baseRE.push(globRegex.replace(glob));
    }
  });
  nameRE = nameRE.length && matchAny(nameRE) || null;
  baseRE = baseRE.length && matchAny(baseRE) || null;
  if (baseRE) {
    if (nameRE) {
      return function(name, base) {
        return baseRE.test(base) || nameRE.test(name);
      };
    } else {
      return function(name, base) {
        return baseRE.test(base);
      };
    }
  } else {
    return function(name, base) {
      return nameRE.test(name);
    };
  }
};

Follower = function(match) {
  return function(name, root) {
    var depth, link, mode, target;
    depth = 0;
    if (!match(name, depth)) {
      return null;
    }
    link = root + name;
    while (true) {
      target = readlinkSync(link);
      if (path.isAbsolute(target)) {
        name = null;
        link = target;
      } else {
        if (name !== null) {
          name = relative(name, target);
        }
        link = name === null ? path.resolve(path.dirname(link), target) : root + name;
      }
      try {
        mode = lstatSync(link).mode & S_IFMT;
      } catch (error) {}
      if (mode !== S_IFLNK || !match(name != null ? name : link, ++depth)) {
        break;
      }
    }
    return name != null ? name : link;
  };
};
